mod channel;
mod context;
mod result;

pub use channel::*;
pub use context::*;
pub use lapin;

use lapin::options::{BasicConsumeOptions, BasicNackOptions};
use lapin::Channel;
use std::future::Future;
use std::sync::Arc;
use tokio::task::{JoinError, JoinHandle};
use tokio_stream::StreamExt;

use crate::event::Decode;
use lapin::types::FieldTable;
use result::AMQPResult;

pub struct Streameroo {
    context: Arc<Context>,
    consumer_tag: String,
    tasks: Vec<JoinHandle<()>>,
}

impl Streameroo {
    pub fn new(context: Context, consumer_tag: impl Into<String>) -> Self {
        Self {
            context: Arc::new(context),
            consumer_tag: consumer_tag.into(),
            tasks: Vec::new(),
        }
    }

    pub fn channel(&self) -> &Channel {
        &self.context.channel
    }

    pub async fn join(self) -> Result<(), JoinError> {
        for task in self.tasks {
            task.await?;
        }
        Ok(())
    }

    pub async fn consume<P, T, E>(
        &mut self,
        handler: impl AMQPHandler<P, T, E>,
        queue: impl AsRef<str>,
        options: BasicConsumeOptions,
        arguments: FieldTable,
    ) -> lapin::Result<()>
    where
        T: AMQPResult,
    {
        let context: Arc<Context> = self.context.clone();
        let mut consumer = context
            .channel
            .basic_consume(queue.as_ref(), &self.consumer_tag, options, arguments)
            .await?;
        let task = tokio::spawn(async move {
            loop {
                if let Some(attempted_delivery) = consumer.next().await {
                    match attempted_delivery {
                        Ok(delivery) => {
                            let context = context.clone();
                            let handler = handler.clone();
                            tokio::spawn(async move {
                                let (delivery_context, payload) =
                                    context::create_delivery_context(delivery, context);
                                match handler.call(payload, &delivery_context).await {
                                    Ok(ret) => match ret.handle_result(&delivery_context).await {
                                        Ok(_) => {
                                            if let Err(e) =
                                                delivery_context.acker.ack(Default::default()).await
                                            {
                                                tracing::error!(?e, "Error acking delivery");
                                            }
                                        }
                                        Err(e) => {
                                            tracing::error!(?e, "Error processing AMQPResult");
                                            if let Err(e) = delivery_context
                                                .acker
                                                .nack(BasicNackOptions {
                                                    requeue: true,
                                                    multiple: false,
                                                })
                                                .await
                                            {
                                                tracing::error!(?e, "Error nacking delivery");
                                            }
                                        }
                                    },
                                    Err(e) => {
                                        tracing::error!(?e, "Handler error");
                                        if let Err(e) = delivery_context
                                            .acker
                                            .nack(BasicNackOptions {
                                                requeue: true,
                                                multiple: false,
                                            })
                                            .await
                                        {
                                            tracing::error!(?e, "Error nacking delivery");
                                        }
                                    }
                                }
                            });
                        }
                        Err(e) => {
                            tracing::error!(?e, "Error consuming delivery");
                        }
                    }
                }
            }
        });
        self.tasks.push(task);
        Ok(())
    }
}

type BoxError = Box<dyn std::error::Error + Send + Sync + 'static>;

// P: Type for the parameters of the future generating closure
// T: Type for the return value of the future generated by the closure
// E: Error type of the handler
pub trait AMQPHandler<P, T, Err>: Clone + Send + 'static
where
    T: AMQPResult,
{
    fn call(
        &self,
        payload: Vec<u8>,
        delivery_context: &DeliveryContext,
    ) -> impl Future<Output = Result<T, Error>> + Send;
}

#[derive(Debug, thiserror::Error)]
pub enum Error {
    #[error("Handler error: {0}")]
    Handler(BoxError),
    #[error("Event error: {0}")]
    EventDecode(BoxError),
    #[error("Lapin error: {0}")]
    Lapin(#[from] lapin::Error),
}

macro_rules! impl_handler {
    (
        [$($ty:ident),*]
    ) => {
        #[allow(non_snake_case, unused_variables, unused_parens)]
        impl<F, Fut, T, Err, $($ty,)* E> AMQPHandler<($($ty,)* E), T, Err> for F
        where
            F: Fn($($ty,)* E) -> Fut + Send + Sync + 'static + Clone,
            Err: Into<BoxError>,
            Fut: Future<Output = Result<T, Err>> + Send,
            $( $ty: for<'a> FromDeliveryContext<'a>, )*
            E: Decode,
            T: AMQPResult,
        {
            async fn call(&self, payload: Vec<u8>, delivery_context: &DeliveryContext) -> Result<T, Error> {
                let event = E::decode(payload).map_err(|e| Error::EventDecode(e.into()))?;
                $(
                    let $ty = $ty::from_delivery_context(&delivery_context);
                )*
                self($($ty,)* event).await.map_err(|e| Error::Handler(e.into()))
            }
        }
    };
}

impl_handler!([]);
impl_handler!([T1]);
impl_handler!([T1, T2]);
impl_handler!([T1, T2, T3]);
impl_handler!([T1, T2, T3, T4]);
impl_handler!([T1, T2, T3, T4, T5]);
impl_handler!([T1, T2, T3, T4, T5, T6]);
impl_handler!([T1, T2, T3, T4, T5, T6, T7]);
impl_handler!([T1, T2, T3, T4, T5, T6, T7, T8]);
impl_handler!([T1, T2, T3, T4, T5, T6, T7, T8, T9]);
impl_handler!([T1, T2, T3, T4, T5, T6, T7, T8, T9, T10]);
impl_handler!([T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11]);
impl_handler!([T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12]);
impl_handler!([T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13]);

#[cfg(test)]
mod test {
    use lapin::Connection;
    use serde::{Deserialize, Serialize};
    use std::sync::atomic::{AtomicU8, Ordering};
    use std::time::{Duration, Instant};
    use test_context::{test_context, AsyncTestContext};

    use super::*;
    use crate::event::Json;

    struct AMQPTest {
        channel: Channel,
    }

    #[derive(Debug, Serialize, Deserialize)]
    struct TestEvent(String);

    impl AsyncTestContext for AMQPTest {
        async fn setup() -> Self {
            tracing_subscriber::fmt().init();
            let url = "amqp://user:password@localhost:5672";
            let connection = Connection::connect(url, Default::default())
                .await
                .expect("Failed to connect to broker");
            tokio::time::sleep(Duration::from_millis(100)).await;
            let channel = connection.create_channel().await.unwrap();
            Self { channel }
        }
        async fn teardown(self) {
            self.channel.close(0, "bye").await.unwrap();
        }
    }

    async fn test_event_handler(
        counter: StateOwned<Arc<AtomicU8>>,
        event: Json<TestEvent>,
    ) -> anyhow::Result<()> {
        let event = event.into_inner();
        assert_eq!(event.0, "hello");
        let count = counter.load(Ordering::Relaxed);
        tracing::info!(?count);
        if count < 3 {
            counter.fetch_add(1, Ordering::Relaxed);
            anyhow::bail!("Go again");
        }
        Ok(())
    }

    #[test_context(AMQPTest)]
    #[tokio::test]
    async fn test_context(ctx: &mut AMQPTest) -> anyhow::Result<()> {
        ctx.channel
            .queue_declare("test", Default::default(), Default::default())
            .await?;
        let counter = Arc::new(AtomicU8::new(0));
        let mut context = Context::new(ctx.channel.clone());
        context.data(counter.clone());

        let mut app = Streameroo::new(context, "test-consumer");
        app.consume(
            test_event_handler,
            "test",
            Default::default(),
            Default::default(),
        )
        .await?;
        ctx.channel
            .publish(
                "",
                "test",
                Default::default(),
                Default::default(),
                Json(TestEvent("hello".into())),
            )
            .await?;
        let t = Instant::now();
        loop {
            if counter.load(Ordering::Relaxed) == 3 {
                break;
            }
            if t.elapsed().as_secs() > 5 {
                panic!("Test timed out");
            }
            tokio::time::sleep(Duration::from_millis(100)).await;
        }
        Ok(())
    }
}
